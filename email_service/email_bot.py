import os
import smtplib
import ssl
import re
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.application import MIMEApplication
import logging
from datetime import datetime

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(os.path.join(os.path.dirname(__file__), 'email_service.log')),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger('email_service')

# Function to remove emojis from text
def remove_emojis(text):
    if text is None:
        return ""
    # Pattern to match emoji characters
    emoji_pattern = re.compile(
        "["
        "\U0001F600-\U0001F64F"  # emoticons
        "\U0001F300-\U0001F5FF"  # symbols & pictographs
        "\U0001F680-\U0001F6FF"  # transport & map symbols
        "\U0001F700-\U0001F77F"  # alchemical symbols
        "\U0001F780-\U0001F7FF"  # Geometric Shapes
        "\U0001F800-\U0001F8FF"  # Supplemental Arrows-C
        "\U0001F900-\U0001F9FF"  # Supplemental Symbols and Pictographs
        "\U0001FA00-\U0001FA6F"  # Chess Symbols
        "\U0001FA70-\U0001FAFF"  # Symbols and Pictographs Extended-A
        "\U00002702-\U000027B0"  # Dingbats
        "\U000024C2-\U0001F251" 
        "]+"
    )
    return emoji_pattern.sub(r'', text)

class EmailBot:
    def __init__(self, sender_email=None, sender_password=None, smtp_server="smtp.gmail.com", smtp_port=465):
        """
        Initialize the EmailBot with sender credentials.
        
        Args:
            sender_email (str): The email address used to send reports. If None, will attempt to load from environment variables.
            sender_password (str): The password or app password for the sender email. If None, will attempt to load from environment variables.
            smtp_server (str): SMTP server address.
            smtp_port (int): SMTP server port.
        """
        # Try to get credentials from environment variables if not provided
        self.sender_email = sender_email or os.environ.get('EMAIL_BOT_ADDRESS')
        self.sender_password = sender_password or os.environ.get('EMAIL_BOT_PASSWORD')
        
        if not self.sender_email or not self.sender_password:
            logger.warning("Email credentials not provided. Set them when initializing or via environment variables.")
        
        self.smtp_server = smtp_server
        self.smtp_port = smtp_port
    
    def send_report(self, recipient_email, report_file_path, subject=None, body=None):
        """
        Send the meeting report to the specified email address.
        
        Args:
            recipient_email (str): The email address of the recipient.
            report_file_path (str): Path to the report file to be attached.
            subject (str, optional): Email subject. Defaults to a generic subject.
            body (str, optional): Email body. Defaults to a generic message.
            
        Returns:
            bool: True if email was sent successfully, False otherwise.
        """
        if not self.sender_email or not self.sender_password:
            logger.error("Sender email credentials not set. Cannot send email.")
            return False
            
        if not os.path.exists(report_file_path):
            logger.error(f"Report file not found: {report_file_path}")
            return False
            
        # Create default subject and body if not provided
        if not subject:
            subject = f"Meeting Report - {datetime.now().strftime('%Y-%m-%d %H:%M')}"
        
        if not body:
            body = (
                "Hello,\n\n"
                "Attached is your meeting report generated by our Meeting Report Creator.\n\n"
                "Thank you for using our service.\n\n"
                "Best regards,\nMeeting Report Creator Bot"
            )
            
        # Remove emojis from subject and body to avoid encoding issues
        subject = remove_emojis(subject)
        body = remove_emojis(body)
        
        # Create the email
        message = MIMEMultipart()
        message["From"] = self.sender_email
        message["To"] = recipient_email
        message["Subject"] = subject
        
        # Add body to email with explicit UTF-8 encoding
        message.attach(MIMEText(body, "plain", "utf-8"))
        
        # Add attachment
        with open(report_file_path, "rb") as attachment:
            part = MIMEApplication(attachment.read(), Name=os.path.basename(report_file_path))
        
        # Add header as key/value pair to attachment part
        part["Content-Disposition"] = f'attachment; filename="{os.path.basename(report_file_path)}"'
        message.attach(part)
        
        # Send the email
        try:
            # Create a secure SSL context
            context = ssl.create_default_context()
            
            with smtplib.SMTP_SSL(self.smtp_server, self.smtp_port, context=context) as server:
                server.login(self.sender_email, self.sender_password)
                server.sendmail(self.sender_email, recipient_email, message.as_string())
            
            logger.info(f"Email sent successfully to {recipient_email}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to send email: {e}")
            return False

    def validate_email(self, email):
        """
        Basic validation of email format.
        
        Args:
            email (str): Email address to validate.
            
        Returns:
            bool: True if email format is valid, False otherwise.
        """
        import re
        # Basic pattern for email validation
        pattern = r'^[\w\.-]+@[\w\.-]+\.\w+$'
        return bool(re.match(pattern, email)) 